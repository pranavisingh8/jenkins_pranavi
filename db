#BFS:
import networkx as nx
import matplotlib.pyplot as plt
from collections import deque

class Graph:
    def __init__(self):
        self.edges = []        # For visualization
        self.adj = {}          # Adjacency list

    def add_edge(self, u, v):
        self.edges.append((u, v))
        if u not in self.adj:
            self.adj[u] = []
        if v not in self.adj:
            self.adj[v] = []
        self.adj[u].append(v)
        self.adj[v].append(u)

    def visualize(self):
        g = nx.Graph()
        g.add_edges_from(self.edges)
        nx.draw_networkx(g)
        plt.title("Original Graph")
        plt.show()

    def bfs(self, start):
        queue = deque([start])
        visited = set()
        traversal = []
        parent = {start: None}

        while queue:
            node = queue.popleft()
            if node not in visited:
                visited.add(node)
                traversal.append(node)
                for neighbor in self.adj[node]:
                    if neighbor not in visited and neighbor not in queue:
                        queue.append(neighbor)
                        parent[neighbor] = node

        print("BFS Traversal:", traversal)
        self.visualize_tree(parent)

    def visualize_tree(self, parent):
        tree_edges = [(parent[n], n) for n in parent if parent[n] is not None]
        tree = nx.Graph()
        tree.add_edges_from(tree_edges)
        nx.draw_networkx(tree)
        plt.title("BFS Tree")
        plt.show()

G = Graph()

n = int(input("Enter number of edges: "))
print("Enter each edge as two space-separated nodes (u v):")
for _ in range(n):
    u, v = map(int, input().split())
    G.add_edge(u, v)


start_node = int(input("Enter start node for DFS: "))
G.visualize()
G.bfs(start_node)

#dfs: rec csv
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

class Graph:
    def __init__(self):
        self.edges = []
        self.adj = {}

    def add_edge(self, u, v):
        self.edges.append((u, v))
        if u not in self.adj:
            self.adj[u] = []
        if v not in self.adj:
            self.adj[v] = []
        self.adj[u].append(v)
        self.adj[v].append(u)

    def visualize(self):
        G = nx.Graph()
        G.add_edges_from(self.edges)
        nx.draw_networkx(G)
        plt.title("Original Graph")
        plt.show()

    def dfs_recursive(self, node, visited, parent, traversal):
        visited.add(node)
        traversal.append(node)
        if node in self.adj:
            for neighbor in self.adj[node]:
                if neighbor not in visited:
                    parent[neighbor] = node  # Track parent
                    self.dfs_recursive(neighbor, visited, parent, traversal)

    def dfs(self, start):
        visited = set()
        traversal = []
        parent = {start: None}  # Store parent-child relationships for DFS tree

        self.dfs_recursive(start, visited, parent, traversal)

        print("DFS Traversal:", traversal)
        self.visualize_tree(parent)

    def visualize_tree(self, parent):
        tree_edges = [(parent[node], node) for node in parent if parent[node] is not None]
        tree = nx.Graph()
        tree.add_edges_from(tree_edges)
        nx.draw_networkx(tree)
        plt.title("DFS Tree")
        plt.show()

G = Graph()

df = pd.read_csv('/content/graph.csv')  
for idx, row in df.iterrows():
    G.add_edge(int(row['source']), int(row['destination']))

start_node = int(input("Enter start node for DFS: "))
G.visualize()
G.dfs(start_node)


#dfs non rec user
import networkx as nx
import matplotlib.pyplot as plt

class Graph:
    def __init__(self):
        self.edges = []          # Stores all edges
        self.graph = {}          # Adjacency list

    def add_edge(self, u, v):
        self.edges.append((u, v))
        if u not in self.graph:
            self.graph[u] = []
        if v not in self.graph:
            self.graph[v] = []
        self.graph[u].append(v)
        self.graph[v].append(u)  # Because it's an undirected graph

    def dfs_iterative(self, start):
        visited = set()
        stack = [start]
        parent = {start: None}
        result = []

        while stack:
            node = stack.pop()
            if node not in visited:
                visited.add(node)
                result.append(node)

                # Add neighbors to stack (reverse for correct DFS order)
                for neighbor in reversed(self.graph.get(node, [])):
                    if neighbor not in visited:
                        stack.append(neighbor)
                        parent[neighbor] = node

        print("DFS Traversal:", result)
        self.visualize_tree(parent)

    def visualize(self):
        g = nx.Graph()
        g.add_edges_from(self.edges)
        nx.draw_networkx(g)
        plt.show()

    def visualize_tree(self, parent):
        tree_edges = [(parent[n], n) for n in parent if parent[n] is not None]
        tree = nx.Graph()
        tree.add_edges_from(tree_edges)
        nx.draw_networkx(tree)
        plt.show()

G = Graph()

n = int(input("Enter number of edges: "))
print("Enter each edge as two space-separated nodes (u v):")
for _ in range(n):
    u, v = map(int, input().split())
    G.add_edge(u, v)


start_node = int(input("Enter start node for DFS: "))
G.visualize()
G.dfs_iterative(start_node)

